
*** debug ***
11725번 디버그 코드
for(int i= 0;i<n;i++){
    for(int j = 0;j<t[i].vec.size();j++){
        cout<< t[i].vec[j].data;
    }
}

*** 백준 2164번 카드2 ***

1 2 3 4 이렇게 있다고 가정

stl deque를 사용할 생각

문제의 설명에 의하면 
1 번을 제거하고 2번은 4번 뒤로 옮김. 이 과정을 코드로 구현해보면
deque<int> deq; // 덱의 선언

deq.pop_front(); // 1번을 제거한다. 
deq.push_back(deq.front()); deq.pop_front(); // 2번을 4번 뒤에 넣은 뒤, 2를 삭제한다.
while(deq.size() != 1) // 이 과정을 덱이 하나만 남을 때 까지 반복한다. 

*** 백준 1927번 최소힙 ***

문제 자체가 자료구조이기 때문에 알고리즘이라고 할 만한 것이 없음.

stl 우선순위 큐를 사용하여 품
우선순위 큐가 즉 힙이기 때문에 우선순위 큐를 사용했다.

후기 : stl을 사용하여 쉽게 풀었지만 
    조만간 stl을 사용하지 않고 힙을 직접구현하여 풀 생각이다.
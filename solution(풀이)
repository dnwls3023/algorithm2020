풀이 사용 방법 : ctrl + f 를 사용하여 원하는 문제를 찾으면 된다.

*** debug ***
11725번 디버그 코드
for(int i= 0;i<n;i++){
    for(int j = 0;j<t[i].vec.size();j++){
        cout<< t[i].vec[j].data;
    }
}

*** 백준 2164번 카드2 ***

1 2 3 4 이렇게 있다고 가정

stl deque를 사용할 생각

문제의 설명에 의하면 
1 번을 제거하고 2번은 4번 뒤로 옮김. 이 과정을 코드로 구현해보면
deque<int> deq; // 덱의 선언

deq.pop_front(); // 1번을 제거한다. 
deq.push_back(deq.front()); deq.pop_front(); // 2번을 4번 뒤에 넣은 뒤, 2를 삭제한다.
while(deq.size() != 1) // 이 과정을 덱이 하나만 남을 때 까지 반복한다. 

*** 백준 1927번 최소힙 ***

문제 자체가 자료구조이기 때문에 알고리즘이라고 할 만한 것이 없음.

stl 우선순위 큐를 사용하여 품
우선순위 큐가 즉 힙이기 때문에 우선순위 큐를 사용했다.

후기 : stl을 사용하여 쉽게 풀었지만 
    조만간 stl을 사용하지 않고 힙을 직접구현하여 풀 생각이다.

*** 코드포스 div2 - a번 : Three Indices ***

문제 설명:

순열 p1,p2,p3, ... ,pn 이 주어진다. 
여기서 이 조건(후술함)을 만족하는 순열의 인덱스 값을 출력하는 되는 문제이다. 
(참고로 정답은 여러개일 수 있으며 코드포스의 예제 답이랑 일치하지 않아도 
문제의 조건만 맞으면 정답으로 처리 될 수 있다.)

조건 :
    1 <= i < j < k <= n
    pi < pj && pj > pk

조건을 이해하면 절반은 먹고 들어간다.

알고리즘 설명: 
p의 크기 Combination 3 한 값 중에 조건에 맞는 최초의 인덱스 값을 출력한다.

ex) 2 1 4 3 일 때 4C3 이므로
    i j k
    2 1 4
    2 1 3 
    2 4 3
    1 4 3 
이 나오고 여기서 조건이 성립하는 것은 다음과 같다.

i j k 
2 1 4 (조건성립 x)
2 1 3 (조건성립 x)
2 4 3 (조건성립 o) : 여기서 인덱스값을 출력한 뒤 return; (여기서 함수가 종료된다.)
1 4 3 (조건성립 o)

여기서까지의 알고리즘을 코드로 나타내면

// 시간초과가 나는 코드
for(int i= 0; i<n-2;i++){
    for(int j= i+1;j<n-1;j++){
        if(arr[i] < arr[j]){
            for(int k= j+2;k<n;k++){
                if(arr[j] > arr[k]){
                    cout<<"YES"<<"\n";
                    cout<< i+1 <<" "<<j+1<<" "<<k+1 <<"\n";
                    return;
                }
            }
        }
    }
}
cout<<"NO"<<"\n";

으로 나타낼 수 있다. 하지만 이 알고리즘으로 코드를 제출했을 때 TLE(시간초과)가 나게 된다.
따라서 for문에 들어가기 전에 이 조건이 성립하는지 확인하는 코드를 작성한다. 

// 수정한 코드
for(int i= 0; i<n-2;i++){
    if(arr[i] < arr[i+1]){
        for(int j= i+1;j<n-1;j++){
            if(arr[j] > arr[j+1]){
                for(int k= j+2;k<n;k++){
                    cout<<"YES"<<"\n";
                    cout<< i+1 <<" "<<j+1<<" "<<k+1 <<"\n";
                    return;
                }
            }
        }
    }
}
cout<<"NO"<<"\n";

이렇게 수정하게 되면 for문을 들어가기 전 조건을 만족하는지에 대한 여부를 알 수 있고
조건을 만족하지 않으면 바로 다음 인덱스 값으로 넘어가게 되어 시간이 많이 절약된다.

